// Autogenerated from "./Nebula.glsl"

import * as PIXI from "pixi.js";


interface UniformData
{
  baseColor: {type: "vec3"; value: number[]};
  cloudLightness: {type: "float"; value: number};
  coverage: {type: "float"; value: number};
  diffusion: {type: "float"; value: number};
  highlightA: {type: "float"; value: number};
  highlightB: {type: "float"; value: number};
  highlightColor: {type: "vec3"; value: number[]};
  nebulaStarConcentration: {type: "float"; value: number};
  overlayColor: {type: "vec3"; value: number[]};
  scale: {type: "float"; value: number};
  seed: {type: "vec2"; value: number[]};
  starBrightness: {type: "float"; value: number};
  starDensity: {type: "float"; value: number};
  streakLightness: {type: "float"; value: number};
  streakiness: {type: "float"; value: number};
}

type Uniforms = {[K in keyof UniformData]: UniformData[K]["value"]};

export default class Nebula extends PIXI.Filter<Uniforms>
{
  constructor(initialUniformValues?: Partial<Uniforms>)
  {
    const uniformData = Nebula.makeUniformDataObject(initialUniformValues);
    super(undefined, sourceLines.join("\n"), uniformData);
  }

  private static makeUniformDataObject(initialValues: Partial<Uniforms> = {}): UniformData
  {
    return(
    {
      baseColor: {type: "vec3", value: initialValues.baseColor},
      cloudLightness: {type: "float", value: initialValues.cloudLightness},
      coverage: {type: "float", value: initialValues.coverage},
      diffusion: {type: "float", value: initialValues.diffusion},
      highlightA: {type: "float", value: initialValues.highlightA},
      highlightB: {type: "float", value: initialValues.highlightB},
      highlightColor: {type: "vec3", value: initialValues.highlightColor},
      nebulaStarConcentration: {type: "float", value: initialValues.nebulaStarConcentration},
      overlayColor: {type: "vec3", value: initialValues.overlayColor},
      scale: {type: "float", value: initialValues.scale},
      seed: {type: "vec2", value: initialValues.seed},
      starBrightness: {type: "float", value: initialValues.starBrightness},
      starDensity: {type: "float", value: initialValues.starDensity},
      streakLightness: {type: "float", value: initialValues.streakLightness},
      streakiness: {type: "float", value: initialValues.streakiness},
    });
  }

  public setUniforms(uniforms: Partial<Uniforms>): void
  {
    for (const key in uniforms)
    {
      this.uniforms[key] = uniforms[key];
    }
  }
}

const sourceLines =
[
  "precision mediump float;",
  "",
  "#define DOMAIN 0 // 0 == pixi, 1 == shdr.bkcore.com",
  "",
  "#if DOMAIN == 0",
  "  uniform vec3 baseColor;",
  "  uniform vec3 overlayColor;",
  "  uniform vec3 highlightColor;",
  "",
  "  uniform float coverage;",
  "",
  "  uniform float scale;",
  "",
  "  uniform float diffusion;",
  "  uniform float streakiness;",
  "",
  "  uniform float streakLightness;",
  "  uniform float cloudLightness;",
  "",
  "  uniform float highlightA;",
  "  uniform float highlightB;",
  "",
  "  uniform float starDensity;",
  "  uniform float nebulaStarConcentration;",
  "  uniform float starBrightness;",
  "",
  "  uniform vec2 seed;",
  "#elif DOMAIN == 1",
  "  const vec3 baseColor = vec3(1.0, 0.0, 0.0);",
  "  const vec3 overlayColor = vec3(0.0, 0.0, 1.0);",
  "  const vec3 highlightColor = vec3(1.0, 1.0, 1.0);",
  "",
  "  const float coverage = 0.3;",
  "  const float coverage2 = coverage / 2.0;",
  "",
  "  const float scale = 4.0;",
  "",
  "  const float diffusion = 3.0;",
  "  const float streakiness = 2.0;",
  "",
  "  const float streakLightness = 1.0;",
  "  const float cloudLightness = 1.0;",
  "",
  "  const float highlightA = 0.9;",
  "  const float highlightB = 2.2;",
  "",
  "  const float starDensity = 0.0008;",
  "  const float nebulaStarConcentration = 0.01;",
  "  const float starBrightness = 0.6;",
  "",
  "  const vec2 seed = vec2(69.0, 42.0);",
  "#endif",
  "",
  "const int sharpness = 6;",
  "",
  "float hash(vec2 p)",
  "{",
  "  return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x))));",
  "}",
  "",
  "float noise(vec2 x)",
  "{",
  "  vec2 i = floor(x);",
  "  vec2 f = fract(x);",
  "  float a = hash(i);",
  "  float b = hash(i + vec2(1.0, 0.0));",
  "  float c = hash(i + vec2(0.0, 1.0));",
  "  float d = hash(i + vec2(1.0, 1.0));",
  "  vec2 u = f * f * (3.0 - 2.0 * f);",
  "  return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;",
  "}",
  "",
  "float fbm(vec2 x)",
  "{",
  "  float v = 0.0;",
  "  float a = 0.5;",
  "  vec2 shift = vec2(100);",
  "  mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));",
  "  for (int i = 0; i < sharpness; ++i)",
  "  {",
  "    v += a * noise(x);",
  "    x = rot * x * 2.0 + shift;",
  "    a *= 0.5;",
  "    }",
  "  return v;",
  "}",
  "",
  "float relativeValue(float v, float min, float max)",
  "{",
  "  return (v - min) / (max - min);",
  "}",
  "",
  "float displace(vec2 pos, out vec2 q)",
  "{",
  "  q = vec2(fbm(pos),",
  "    fbm(pos + vec2(23.3, 46.7)));",
  "  return fbm(pos + vec2(q.x * streakiness, q.y));",
  "}",
  "",
  "vec3 colorLayer(vec2 pos, vec3 color)",
  "{",
  "  float v = fbm(pos);",
  "  return mix(vec3(0.0), color, v);",
  "}",
  "",
  "vec3 nebula(vec2 pos, out float volume)",
  "{",
  "  vec2 on = vec2(0.0);",
  "",
  "  volume = displace(pos, on);",
  "  volume = relativeValue(volume, coverage, streakLightness);",
  "  volume += relativeValue(fbm(pos), coverage, cloudLightness);",
  "  volume = pow(volume, diffusion);",
  "",
  "  vec3 c = colorLayer(pos + vec2(42.0, 6.9), baseColor);",
  "  c = mix(c, overlayColor, dot(on.x, on.y));",
  "  c = mix(c, highlightColor, volume *",
  "    smoothstep(highlightA, highlightB, abs(on.x)+abs(on.y)));",
  "",
  "",
  "  return c * volume;",
  "}",
  "",
  "float star(vec2 pos, float volume)",
  "{",
  "  float h = hash(pos);",
  "",
  "  float intensityCutoff = (1.0 - starDensity) - (volume * nebulaStarConcentration);",
  "  float starIntensity = smoothstep(intensityCutoff, 1.0, h);",
  "",
  "  return starIntensity * starBrightness;",
  "}",
  "",
  "void main(void)",
  "{",
  "  vec2 pos = gl_FragCoord.xy / 50.0 / scale;",
  "  pos += seed;",
  "  float volume = 0.0;",
  "  vec3 c = nebula(pos, volume);",
  "  c += vec3(star(pos, volume));",
  "",
  "  gl_FragColor = vec4(c, 1.0);",
  "}",
];

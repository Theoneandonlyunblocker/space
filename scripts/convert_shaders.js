"use strict";

process.on("unhandledRejection", err => {
  throw err;
});

const fs = require("fs");
const glob = require("glob");
const path = require("path").posix;


const typeScriptTypes = {
  "bool": "boolean",
  "int": "number",
  "float": "number",
  "vec2": "number[]",
  "vec3": "number[]",
  "vec4": "number[]",
  "ivec2": "number[]",
  "ivec3": "number[]",
  "ivec4": "number[]",
  "mat2": "number[][]",
  "mat3": "number[][]",
  "mat4": "number[][]",
  "sampler2D": "PIXI.Texture"
};

const pixiUniforms = [
  "vTextureCoord",
  "uSampler"
];

const uniformKeyword = "uniform ";
const keyWordPattern = /\w+/;
const stripDomainPattern = /^([ \t]*)#if DOMAIN == \d\n([\s\S]+?)#elif[\s\S]+?#endif/gm;


function processGlslSource(inputSource)
{
  let source = resolveDomainDeclarations(inputSource);

  return source;
}

function resolveDomainDeclarations(inputSource)
{
  let source = inputSource;

  source = source.replace(/#define DOMAIN[\s\S]+?#/, "#");

  let match;
  while ((match = stripDomainPattern.exec(inputSource)) !== null)
  {
    const fullDomainDeclaration = match[0];
    const blockWhiteSpace = match[1];
    const domainContents = match[2];

    const strippedDomainContents = domainContents
      .replace(/^[ \t]*/gm, blockWhiteSpace)
      .replace(/\s+?$/g, "");

    source = source.replace(fullDomainDeclaration, strippedDomainContents);
  }

  return source;
}


// very naive but im not gonna include a parser just for this
function getGLSLUniformTypes(source)
{
  const sourceLines = source.split("\n");
  const uniformTypes = {};

  for (let i = 0; i < sourceLines.length; i++)
  {
    const line = sourceLines[i];

    const uniformKeyWordIndex = line.indexOf(uniformKeyword);
    if (uniformKeyWordIndex !== -1)
    {
      const lineBeforeUniformKeyWord = line.slice(0, uniformKeyWordIndex);
      if (lineBeforeUniformKeyWord.includes("//"))
      {
        continue;
      }

      const split = line.trim().split(" ");
      const glslType = split[1];
      const uniformName = split[2].match(keyWordPattern)[0];
      if (pixiUniforms.includes(uniformName))
      {
        continue;
      }

      uniformTypes[uniformName] = glslType
    }
  }

  return uniformTypes;
}


function generateTypeScriptSource(glslSource, uniformTypes, baseName, extName)
{
  return(
`// Autogenerated from "./${baseName}${extName}"

import * as PIXI from "pixi.js";
import {vertex} from "./vertex";


interface Uniforms
{
${Object.keys(uniformTypes).sort().map(uniformName =>
{
  const uniformType = uniformTypes[uniformName];
  return `  ${uniformName}: ${typeScriptTypes[uniformType]};`;
}).join("\n")}
}

export class ${baseName} extends PIXI.Shader<Uniforms>
{
  constructor(initialUniformValues?: Partial<Uniforms>)
  {
    const program = new PIXI.Program(
      vertex,
      fragmentSource,
      "${baseName}",
    );

    super(program, initialUniformValues);
  }

  public setUniforms(uniforms: Partial<Uniforms>): void
  {
    for (const key in uniforms)
    {
      this.uniforms[key] = uniforms[key];
    }
  }
}

const fragmentSource = \`${glslSource}\`;
`
  );
}


glob("**/*{.glsl,.frag}", (err, fileNames) =>
{
  if (err) {throw err};

  fileNames.forEach(fileName =>
  {
    const extName = path.extname(fileName);
    const baseName = path.basename(fileName, extName);
    const dirName = path.dirname(fileName);
    const outFileName = path.join(dirName, `${baseName}.ts`);

    fs.readFile(fileName, "utf-8", (err, inputSource) =>
    {
      if (err) {throw err};

      const source = processGlslSource(inputSource);

      const uniformTypes = getGLSLUniformTypes(source);

      const outData = generateTypeScriptSource(source, uniformTypes, baseName, extName);

      fs.writeFile(outFileName, outData, (err) =>
      {
        if (err) {throw err};

        console.log(`${fileName} => ${baseName}.ts`);
      });
    });
  });
});

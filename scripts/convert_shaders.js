"use strict";

process.on("unhandledRejection", err => {
  throw err;
});

const fs = require("fs");
const glob = require("glob");
const path = require("path").posix;


const typeScriptTypes = {
  "bool": "boolean",
  "int": "number",
  "float": "number",
  "vec2": "number[]",
  "vec3": "number[]",
  "vec4": "number[]",
  "ivec2": "number[]",
  "ivec3": "number[]",
  "ivec4": "number[]",
  "mat2": "number[][]",
  "mat3": "number[][]",
  "mat4": "number[][]",
  "sampler2D": "PIXI.Texture"
};

// const pixiUniforms = [
//   "vTextureCoord",
//   "uSampler"
// ];

const uniformKeyword = "uniform ";
const keyWordPattern = /\w+/;
const stripDomainPattern = /^([ \t]*)#if DOMAIN == \d\n([\s\S]+?)#elif[\s\S]+?#endif/gm;


function processGlslSource(inputSource)
{
  let source = resolveDomainDeclarations(inputSource);

  return source;
}

function resolveDomainDeclarations(inputSource)
{
  let source = inputSource;

  source = source.replace(/#define DOMAIN[\s\S]+?#/, "#");

  let match;
  while ((match = stripDomainPattern.exec(inputSource)) !== null)
  {
    const fullDomainDeclaration = match[0];
    const blockWhiteSpace = match[1];
    const domainContents = match[2];

    const strippedDomainContents = domainContents
      .replace(/^[ \t]*/gm, blockWhiteSpace)
      .replace(/\s+?$/g, "");

    source = source.replace(fullDomainDeclaration, strippedDomainContents);
  }

  return source;
}


// very naive but im not gonna include a parser just for this
function getGlslUniformTypes(source)
{
  const sourceLines = source.split("\n");
  const uniformTypes = {};

  for (let i = 0; i < sourceLines.length; i++)
  {
    const line = sourceLines[i];

    const uniformKeyWordIndex = line.indexOf(uniformKeyword);
    if (uniformKeyWordIndex !== -1)
    {
      const lineBeforeUniformKeyWord = line.slice(0, uniformKeyWordIndex);
      if (lineBeforeUniformKeyWord.includes("//"))
      {
        continue;
      }

      const split = line.trim().split(" ");
      const glslType = split[1];
      const uniformName = split[2].match(keyWordPattern)[0];
      // if (pixiUniforms.includes(uniformName))
      // {
      //   continue;
      // }

      uniformTypes[uniformName] = glslType
    }
  }

  return uniformTypes;
}


function generateTypeScriptSourceForShader(glslSource, uniformTypes, baseName, extName)
{
  return(
`// Autogenerated from "./${baseName}${extName}"

import * as PIXI from "pixi.js";
import {vertex} from "./vertex";


interface Uniforms
{
${Object.keys(uniformTypes).sort().map(uniformName =>
{
  const uniformType = uniformTypes[uniformName];
  return `  ${uniformName}: ${typeScriptTypes[uniformType]};`;
}).join("\n")}
}

export class ${baseName}Shader extends PIXI.Shader<Uniforms>
{
  constructor(initialUniformValues?: Partial<Uniforms>)
  {
    const program = new PIXI.Program(
      vertex,
      fragmentSource,
      "${baseName}",
    );

    super(program, initialUniformValues);
  }

  public setUniforms(uniforms: Partial<Uniforms>): void
  {
    for (const key in uniforms)
    {
      this.uniforms[key] = uniforms[key];
    }
  }
}

const fragmentSource = \`${glslSource}\`;
`
  );
}
function generateTypeScriptSourceForFilter(glslSource, uniformTypes, baseName, extName)
{
  return(
`// Autogenerated from "./${baseName}${extName}"

import * as PIXI from "pixi.js";


interface Uniforms
{
${Object.keys(uniformTypes).sort().map(uniformName =>
{
  const uniformType = uniformTypes[uniformName];
  return `  ${uniformName}: ${typeScriptTypes[uniformType]};`;
}).join("\n")}
}

export class ${baseName}Filter extends PIXI.Filter<Uniforms>
{
  constructor(initialUniformValues?: Partial<Uniforms>)
  {
    super(undefined, fragmentSource, initialUniformValues);
  }

  public setUniforms(uniforms: Partial<Uniforms>): void
  {
    for (const key in uniforms)
    {
      this.uniforms[key] = uniforms[key];
    }
  }
}

const fragmentSource = \`${glslSource}\`;
`
  );
}

function getBuildTargets(source)
{
  const buildTargetsMatch = source.match(/^\/\/\/[ \t]*tsBuildTargets[ \t]*:[ \t]*(.+?)[ \t]*\n/);
  if (buildTargetsMatch)
  {
    const buildTargetsString = buildTargetsMatch[1];

    const buildTargetIdentifiers = buildTargetsString.split(" ");

    return buildTargetIdentifiers.map(id => buildTargets[id]);
  }
  else
  {
    return [];
  }
}
const buildTargets =
{
  shader:
  {
    generator: generateTypeScriptSourceForShader,
    baseNameExtension: "Shader",
  },
  filter:
  {
    generator: generateTypeScriptSourceForFilter,
    baseNameExtension: "Filter",
  }
}


glob("**/*{.glsl,.frag}", (err, filePaths) =>
{
  if (err) {throw err};

  filePaths.forEach(filePath =>
  {
    const extName = path.extname(filePath);
    const baseName = path.basename(filePath, extName);
    const dirName = path.dirname(filePath);

    fs.readFile(filePath, "utf-8", (err, inputSource) =>
    {
      if (err) {throw err};

      const source = processGlslSource(inputSource);

      const uniformTypes = getGlslUniformTypes(source);

      const buildTargets = getBuildTargets(source);
      buildTargets.forEach(buildTarget =>
      {
        const outFileName = `${baseName}${buildTarget.baseNameExtension}.ts`;
        const outFilePath = path.join(dirName, outFileName);

        const outData = buildTarget.generator(source, uniformTypes, baseName, extName);

        fs.writeFile(outFilePath, outData, (err) =>
        {
          if (err) {throw err};

          console.log(`${filePath} => ${outFileName}`);
        });
      });
    });
  });
});

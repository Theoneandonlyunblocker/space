"use strict";

process.on("unhandledRejection", err => {
  throw err;
});

const fs = require("fs");
const glob = require("glob");
const path = require("path")


const typeScriptTypes = {
  "bool": "boolean",
  "int": "number",
  "float": "number",
  "vec2": "number[]",
  "vec3": "number[]",
  "vec4": "number[]",
  "ivec2": "number[]",
  "ivec3": "number[]",
  "ivec4": "number[]",
  "mat2": "number[][]",
  "mat3": "number[][]",
  "mat4": "number[][]",
  "sampler2D": "PIXI.Texture"
};

const pixiUniforms = [
  "vTextureCoord",
  "uSampler"
];

const uniformKeyword = "uniform ";
const keyWordPattern = new RegExp("\\w+");
const domainPattern = new RegExp("\\d");

// this whole thing is very naive but im not gonna include a parser just for this
function getGLSLUniformTypes(source)
{
  const sourceLines = source.split("\n");
  const uniformTypes = {};
  let currentDomain, currentDomainBlock;

  for (let i = 0; i < sourceLines.length; i++)
  {
    const line = sourceLines[i];

    if (line.includes("#define DOMAIN"))
    {
      currentDomain = line.match(domainPattern)[0];
    }
    else if (line.includes("DOMAIN =="))
    {
      currentDomainBlock = line.match(domainPattern)[0];
    }
    else if (isFinite(currentDomainBlock) && line.includes("#endif"))
    {
      currentDomainBlock = undefined;
    }

    if (isFinite(currentDomainBlock) && currentDomainBlock !== currentDomain)
    {
      continue;
    }

    const uniformKeyWordIndex = line.indexOf(uniformKeyword);
    if (uniformKeyWordIndex !== -1)
    {
      const lineBeforeUniformKeyWord = line.slice(0, uniformKeyWordIndex);
      if (lineBeforeUniformKeyWord.includes("//"))
      {
        continue;
      }

      const split = line.trim().split(" ");
      const glslType = split[1];
      const uniformName = split[2].match(keyWordPattern)[0];
      if (pixiUniforms.includes(uniformName))
      {
        continue;
      }

      uniformTypes[uniformName] = glslType
    }
  }

  return uniformTypes;
}

function generateTypeScriptSource(glslSource, uniformTypes, baseName, extName)
{
  return(
`// Autogenerated from "./${baseName}${extName}"

import * as PIXI from "pixi.js";


interface Uniforms
{
${Object.keys(uniformTypes).sort().map(uniformName =>
{
  const uniformType = uniformTypes[uniformName];
  return `  ${uniformName}: ${typeScriptTypes[uniformType]};`;
}).join("\n")}
}

export class ${baseName} extends PIXI.Filter<Uniforms>
{
  constructor(initialUniformValues?: Partial<Uniforms>)
  {
    super(undefined, source, initialUniformValues);
  }

  public setUniforms(uniforms: Partial<Uniforms>): void
  {
    for (const key in uniforms)
    {
      this.uniforms[key] = uniforms[key];
    }
  }
}

const source = \`${glslSource}\`;
`
  );
}

// for all .glsl files
glob("**/*{.glsl,.frag}", (err, fileNames) =>
{
  if (err) {throw err};

  fileNames.forEach(fileName =>
  {
    const extName = path.extname(fileName);
    const baseName = path.basename(fileName, extName);
    const dirName = path.dirname(fileName);
    const outFileName = path.join(dirName, `${baseName}.ts`);

    fs.readFile(fileName, "utf-8", (err, source) =>
    {
      if (err) {throw err};

      const uniformTypes = getGLSLUniformTypes(source);

      const outData = generateTypeScriptSource(source, uniformTypes, baseName, extName);

      fs.writeFile(outFileName, outData, (err) =>
      {
        if (err) {throw err};

        console.log(`${fileName} => ${baseName}.ts`);
      });
    });
  });
});
